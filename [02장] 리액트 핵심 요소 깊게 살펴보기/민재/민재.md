# 2장 리액트 핵심 요소 깊게 살펴보기

# 4회차(2.1~2.2)

## JSX란?

- 리액트에 종속적이지 않은 문법
- JS 표준의 일부가 아님.
  => 트랜스파일러를 거쳐야 JS 런타임이 이해할 수 있는 JS코드로 변환됨
- 트리 구조를 토큰화해 ECMAScript로 변환하는 데 초점을 두고있음.

### JSX의 정의

**JSXElement, JSXAttributes, JSXChildren, JSXString** 등 4가지로 구성.

#### JSXElement

JSX를 이루는 가장 기본적인 요소.

- JSXOpeningElement: JSXClosingElement와 동일한 요소로 같은 단계에서 선언돼 있어야함.
- JSXClosingElement: JSXOpeningElement가 종료됐음을 알림.
- JSXSelfClosingElement: 요소가 시작되고, 스스로 종료되는 형태. 자식을 못가짐.
- JSXFragment: 아무런 요소가 없음 `<></>` <= 같이써야함.

요소명은 대문자로만 시작해야되지 않냐??  
모르겠어. 이따 ㄱㄱ

#### JSXElementName

JSXElement의 요소 이름으로 쓸 수 있는 것.

- JSXIdentifier(실전성 없음)  
  JSX 내부에서 사용가능한 식별자. JS와 동일  
  => `<$></$>`, `<_></_>` 얘네들로만 가능.

  ```JSX
  function Valid() {
    return <$></$>
  }
  ```

- JSXNamespacedName: JSX
  JSXIdentifier:JSXIdentifier의 조합. 서로 다른 식별자를 이어주는 식별자
  => 한개만 묶을수 있음. 두 개 이상 X

  ```JSX
  function Valid() {
    return <foo:bar></foo:bar>
  }
  ```

- JSXMeMberExpression: JSXIdentifier.JSXIdentifier의 조합.  
  => 하나의 식별자로 취급되고, 두 개 이상 O, ":" 랑같이 쓰는거 X
  ```JSX
  function valid() {
    return <foo.bar></foo.bar>
  }
  ```

#### JSXAttributes

JSXElement에 부여할 수 있는 속성.  
=> 필수아님.

#### JSXChildren

JSXElement의 자식.

#### JSXStrings

큰따옴표(""), 작은따옴표(''), JSXText({})를 의미

- JS 에서는 \로 시작하는 이스케이프 만자 형태소를 쓸 때 제약사항이 많음.  
  => jSX는 제약 없이 사용 가능.

  ```JSX
  // 가능
  <p>\</p>

  // Uncaught SyntaxError: Invalid or unexpected token
  let escape1 = "\"
  ```

### JSX 예제

```JSX
// 하나의 요소로 구성
const Component = <A>Oh, Hi!</A>

// 자식이 없음
const Component = <A />

// 옵션을 {}와 전개 연산자로 넣을 수 있다.
const Component = <A {...{ required: true}} />

// 속성만 넣어도 가능.
const Component = <A required />

// 속성과 속성값을 넣을 수 있다.
const Component = <A required = {false} />

// 문자열은 ",' 등으로 감싸주면됨
const const Component = <A alt="이미지" />

// 옵션 값으로 JSXElement도 가능
const Component = <A optionalChildren={<>hi</>} />

// 자식 여러개도 넣을 수 있음.
const const Component =
  <A>
    hi
    <B/>
  </A>
```

리액트에서는 안되는 얘들도 JSX에서 문법 자체로는 유효함.

```JSX
function ComponentA() {
  return <A.B></A.b>
}

function ComponentB() {
  return <A.B.C></A.B.C>
}

function ComponentC() {
  return <A:B.C></A:B.C> //얘는 안되는데?
}

function ComponentD() {
  return <$></$>
}

function ComponentE() {
  return <_></_>
}
```

### JSX는 어떻게 자바스크립트에서 변환될까?

- 다른 JSXElement를 렌더링해야 할 때 요소 전체를 안 감싸도 가능  
  => 반환값이 결국 React.createElement로 귀결되는 것을 파악해야함.

### 정리

- JSX 내부에 JS 문법이 많아질수록 가독성이 떨어지므로 주의.
- JSX가 어떻게 변환되고 결과를 만들어내는지 알아두면 도움됨.
- 상황에 맞춰 직접 createElement를 사용해 컴포넌트를 구성하는 편이 좋을수도?

## 가상 DOM과 리액트 파이버

리액트의 가상 DOM과 실제 DOM을 비교하면서, 가상 DOM을 알아보자.

### DOM과 브라우저 렌더링 과정

웹페이지의 인터페이스. 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보를 담음.
![alt text](image.png)

1. HTML 마크업을 처리하고 DOM 트리를 빌드합니다.
2. CSS 마크업을 처리하고 CSSOM 트리를 빌드합니다.
3. DOM 및 CSSOM을 렌더링 트리로 결합합니다.
4. 렌더링 트리에서 레이아웃을 실행하여 각 노드의 도형을 계산합니다.
5. 개별 노드를 화면에 페인팅합니다.

$코드 예시$

```html
#text { 1. html을 다운로드, 분석 background-color: red; 2. link태그 발견후
style.css 다운 } 3. body 태그 하단의 div의 width로 뷰포트 설정
<!DOCTYPE html> 4. 3번 하단의 div의 width로 뷰포트 설정
<html>
  5. 2번에서 다운로드한 CSS에 id="text" 적용
  <head>
    6. 준비완료! 렌더링ㄱㄱ
    <link rel="stylesheet" type="text/css" href="./style.css" />
    <title>Hello React</title>
  </head>
  <body>
    <div style="width: 100%;">
      <div id="text" style="width: 50%;">Hello World!</div>
    </div>
  </body>
</html>
```

### 가상 DOM의 탄생 배경

1. 렌더링이 완료된 이후에도 사용자의 인터랙션으로 웹페이지가 변경되는 것을 고려해야함.
2. 요소의 위치와 크기를 재계산 해야함. **리페인팅**, **레이아웃** 발생  
   **레이아웃**: 요소의 위치와 크기를 계산하여 페이지 배치를 결정하는 과정.  
   **리페인팅**: 시각적 속성이 변경되어 화면에 다시 그리는 과정.
3. 개발자가 DOM의 모든 변경 사항을 추적해야함.
4. 인터랙션에 모든 DOM의 변경보다 결과만 아는게 편함.  
   => 가상 DOM 탄생

#### 가상 DOM이란?

리액트가 관리하는 가상의 DOM.  
=> 웹페이지가 표시해야 할 DOM을 메모리에 저장하고 리액트가 준비되면, 실제 브라우저의 DOM에 반영함.

### 가상 DOM을 위한 아키텍처, 리액트 파이버
