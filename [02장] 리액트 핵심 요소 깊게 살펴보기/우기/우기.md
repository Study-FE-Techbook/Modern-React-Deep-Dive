## 1.3 클래스

**16.8 버전 전까지 모든 리액트의 컴포넌트는 클래스였다.**
<br>
<br>
🔖 함수형 컴포넌트로 변경된지 얼마 되지 않은 리액트를 더 깊이 있게 알아보자.

### 1.3.1 클래스란 무엇인가?

---

🔖 특정 객체를 만들기 위한 일종의 템플릿과 같은 개념

- 객체를 만들 때 필요한 데이터나 조작 코드를 추상화하여 더 편리하게 생성할 수 있도록 한다.
- JS에서 클래스로 하는 모든 것을 함수로 동일하게 할 수 있다.
  <br>
  <br>

🏷️ 클래스 작성법

```js
class Car {
  // constructor (생성자) 작성
  // 최초 생성 시 어떤 인수를 받을지 결정 및 객체 초기화
  constructor(name) {
    this.name = name;
  }

  // 메서드
  honk() {
    console.log(`${this.name}이(가) 경적을 갈긴다.`);
  }

  // 정적 메서드
  static hello() {
    console.log("안녕? 난 차야");
  }

  // setter
  set age(value) {
    this.carAge = value;
  }

  // getter
  get age() {
    return this.carAge;
  }
}
```

<br>

🏷️ 클래스 사용법

```js
// 미리 정의한 Car 클래스를 이용해 객체 생성
const myCar = new Car("포르쉐");

// 메서드 호출
myCar.honk(); // 포르쉐이(가) 경적을 갈긴다.

// 정적 메서드는 클래스에서 직접 호출한다.
Car.hello(); // 안녕? 난 차야

// 정적 메서드는 클래스로 만든 객체에선 호출이 불가하다.
myCar.hello(); // UncaughtError

// setter를 사용해 값을 할당할 수 있다.
myCar.age = 32; // myCar.carAge = 32;

// getter를 사용해 값을 가져올 수 있다.
console.log(myCar.age, myCar.name); // 32 포르쉐
```

<br>

🔖 클래스 내부 특징

- constructor

> - 생성자로, 객체를 생성하는데 사용
>   <br>
> - 단 하나만 존재 가능(여러개 사용 시 에러)
>   <br>
> - 수행할 작업이 없을 시 생략 가능

<br>

- 프로퍼티

> - 인스턴스 생성 시 내부에 정의할 수 있는 속성값
>   <br>
> - 타입스크립트 활용 시 `private`, `public`, `prottected` 활용 가능

<br>

- getter & setter

> - 클래스에서 값을 가져오거나, 값을 할당할 때 사용
>   <br>
> - 각각 `get`과 `set` 키워드를 사용한다.

<br>

- 인스턴스 메서드

> - 클래스 내부에서 선언한 메서드 (`prototype`에 선언)
>   <br>
> - prototype에 선언했으므로, 클래스를 기반으로 만드는 객체들은 메서드 또한 사용 가능
>   <br>
> - 비교를 위해 `Object.getPrototypeOf` 메서드를 사용 가능하다.

<br>

❗여기서 `prototype` 이란?

- 객체 상속 시 사용하는 객체를 `prototype` 이라 정의한다.
  > - 모든 객체는 **proto**(비표준)이라는 속성을 가지며, 이는 프로토타입을 가리킨다.
  > - 객체의 속성이나 메서드를 검색하고, 없을 시 프로토타입을 참조한다. (프로토타입 체인)

<br>

🏷️ [ProtoType 관련 포스팅](https://www.nextree.co.kr/p7323/)

- 정적 메서드

> - 클래스의 인스턴스가 아닌, 이름으로 호출 가능한 메서드
>   <br>
>   클래스 자신을 가리키므로, this 사용이 불가하고 인스턴스에서도 호출 불가하다.
>   <br>
>   객체를 생성하지 않아도 여러 곳에서 사용 가능하여, 전역적 유틸 함수로 활용한다.

<br>

- 상속

> - 부모-자식 관계와 같이 다른 클래스에 속성들을 상속시켜 확장하는 개념
>   <br>
> - extends 키워드를 활용하여 다양하게 파생된 클래스 생성이 가능하다.

<br>

### 1.3.2 클래스와 함수의 관계

---

🔖 클래스가 작동하는 방식은 JS의 `prototype`을 활용하는 것

```js
// 프로토타입를 활용한 JS의 클래스 구현
const Car = (function () {
  function Car(name){
    this.name = name;
  }

  Car.prototpye.honk = function () {
    console.log(`${this.name}이(가) 경적을 갈긴다.`);
  }

  Car.hello = function () {
    console.log(`안녕? 난 차야`);
  }

  Car.defineProperty(Car, 'age'){
    get: function () {
      return this.carAge
    },
    set: function () {
      this.carAge = value
    }
  }
  return Car;
  })()
```

<br>

### 1.3.3 책 정리 + 주관적인 정리

---

🔖 책 정리

- 다른 객체지향언어와 비슷한 수준으로 JS의 클래스도 여러가지 기능을 제공한다.

- 클래스 이해를 통해 클래스 컴포넌트에 생명주기 구현 및 상속, 함수 표현 방식에 따른 차이를 이해할 수 있다.

🏷️ 주관적인 정리

- 클래스 컴포넌트는 예전에 리액트 라이프 사이클을 공부할 때 잠깐 스쳐지나간 기억이 있는데, 이런 식으로 리액트 전반에 관련된 중요한 개념인 줄 몰랐다.

- 현재 우리가 사용하는 함수형 컴포넌트는 결국 클래스 컴포넌트와 동일한 메커니즘이므로, 클래스를 확실하게 이해한다면 함수형 컴포넌트 작성에도 매우 용이할 듯 하다.

- 더불어 JS 딥다이브에서 공부했던 프로토타입에 관해 다시 정리할 수 있어 좋았다.
