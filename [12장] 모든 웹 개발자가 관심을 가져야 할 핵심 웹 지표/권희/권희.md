# 12장 모든 웹 개발자가 관심을 가져야 할 핵심 웹 지표

## 12.1 웹사이트와 성능

**사용자가 웹사이트에 기대하는 사항**

1. 웹사이트를 방문한 목적을 손쉽게 달성
2. **첫 번째 목적을 달성하는데 걸리는 시간이 짧아야 함**
3. 웹사이트에서 개인정보가 누출되는 등의 사고 없이 보안이 철저해야 함

이 세 가지만 달성할 수 있다면 웹 사이트가 내부적으로 어떤 코드로 어떻게 이뤄져 있는지는 고객들에게 전혀 중요하지 않음

<br>

웹사이트의 성능과 사용자 경험은 비례한다.
그렇다면 웹사이트의 성능은 어떻게 측정할 수 있을까?

구글은 핵심 웹 지표(Core Web Vital)라고 하는, 웹사이트의 우수한 사용자 경험을 제공하는 데 필요한 몇 가지 핵심적인 요소를 꼽고,
이에 대한 지표를 제시하고 있다.

## 12.2 핵심 웹 지표란?

구글에서 핵심 웹 지표로 꼽는 지표는 다음과 같다.

- LCP: 최대 콘텐츠풀 페인트
- FID: 최초 입력 지연
- CLS: 누적 레이아웃 이동

그리고 다음 두 지표는 핵심까지는 아니지만, 특정 문제를 진단하는 데 사용될 수 있다고 언급했다.

- TTFB: 최초 바이트까지의 시간
- FCP: 최초 콘텐츠풀 시간

## 12.3 LCP

> 페이지가 처음으로 로드를 시작한 시점부터 뷰포트 내부에서 가장 큰 이미지 또는 텍스트를 렌더링하는 데 걸리는 시간

뷰포트에 메인 콘텐츠가 화면에 완전히 전달되는 속도를 기준으로 한다면
사용자는 페이지가 로딩이 완료됐다고 체감하는 시간과 매우 비슷하게 측정할 수 있을 것이다.

아래 5가지가 가장 큰 요소로 고려된다.

- `<img>`
- `<svg>` 내부의 `<image>`
- poster 속성을 사용하는 `video`
- `url()`을 통해 불러온 배경 이미지가 있는 요소
- 텍스트 요소를 포함하고 있는 블록 레벨 요소

### 기준 점수

- Good: 2.5초 이내
- Not Good: 4초 이내
- Bad: 4초 이상

### 개선 방안

#### 텍스트는 언제나 옳다

제아무리 이미지를 최적화하더라도 추가적인 리소스 다운로드가 필요한 이미지보다 텍스트 노출이 훨씬 더 빠르다.

#### 이미지는 어떻게 불러올 것인가?

개발자가 선택할 수 있는 이미지를 노출하는 방법에는 다음과 같이 여러가지가 있다.

1. `<img>`
2. `<svg>` 내부의 `<image>`
3. `video`의 poster
4. background-image

로딩 속도가 빠른 것은 1, 3이다.
각각 살펴보자.

1. `<img>`
   이미지는 브라우저의 **프리로드 스캐너**에 의해서 먼저 발견되어 빠르게 요청이 일어난다.
   프리로드 스캐너란 HTML을 파싱하는 단계를 차단하지 않고 이미지와 같이 빠르게 미리 로딩하면 좋은 리소스를 먼저 찾아 로딩하는 브라우저의 기능이다.
   프리로드 스캐너가 병렬적으로 리소스를 다운로드하므로 최대 콘텐츠풀 페인트 요소를 불러오기에 적절한 방법이다.
   이는 `<picture>`도 마찬가지다.
2. `<svg>` 내부의 `<image>`
   `<svg>` 내부의 `<image>`는 프리로드 스캐너에 의해 발견되지 않아 병렬적으로 다운로드가 일어나지 않는다.
3. `video`의 poster
   사용자가 video 요소를 재생하기 전까지 노출되는 요소다.
   이 역시 프리로드 스캐너에 의해 조기에 발견된다.
   poster가 없는 video의 경우 video를 실제로 로딩해 첫 번째 프레임을 해당 poster 리소스로 대체하므로 poster를 반드시 지정해주는 것이 좋다.
4. background-image
   `url():background-image`를 비롯해서 CSS에 있는 리소스는 항상 느리다.
   이러한 리소스는 브라우저가 해당 리소스를 필요로 하는 DOM을 그릴 준비가 될 때까지 리소스 요청을 뒤로 미루기 때문이다.

#### 그 밖에 조심해야 할 사항

- 이미지 무손실 압축
  가능한 무손실 형태로 압축해 최소한의 용량으로 서비스하는 것이 좋다.
- `loading=lazy` 주의
  `loading=lazy`는 리소스를 중요하지 않음으로 표시하고 필요할 때만 로드하는 전략이다.
  최대 콘텐츠풀 콘텐츠의 이미지나 아이콘에는 사용하지 않는 것이 좋다.
- fadein과 같은 각종 애니메이션
- 클라이언트에서 빌드하지 말 것
- 최대 콘텐츠풀 리소스는 직접 호스팅
  가능하다면 최대 콘텐츠풀 리소스는 같은 도메인에서 직접 호스팅하는 것이 좋다.
  Cloudinary 같은 이미지 최적화 서비스를 사용할 수도 있지만, 이는 네트워크 연결을 앞서 수행해야 하기 때문에
  중요한 리소스는 직접 다루고 덜 중요한 리소스에 대해서만 이미지 최적화 서비스를 사용하는 식으로 관리하는 것이 좋다.

## 12.4 FID

> 사용자가 페이지와 처음 상호 작용할 때부터 브라우저가 실제로 이벤트 핸들러 처리를 시작하기까지의 시간

제 아무리 페이지가 빨리 로딩된다 하더라도 사용자가 클릭을 비롯한 웹사이트와 상호작용을 할 수 없다면 사용자는 웹사이트가 느리다고 생각할 것이다.
이렇듯 웹사이트의 로딩 속도만큼 중요한 것이 웹사이트의 반응 속도다.

<br>

웹사이트 내부의 이벤트가 반응이 늦어지는 이유는 대부분 브라우저의 메인 스레드가 바쁘기 때문이다.
그리고 이 메인 스레드가 바쁜 이유는 무언가 대규모 렌더링이 일어나고 있거나 다른 작업을 처리하는 데 리소스를 할애하고 있기 때문이다.

**정리하자면, 최초 입력 지연이란 화면이 최초에 그려지고 난 뒤, 사용자가 웹페이지에서 상호작용을 수행했을 때 메인 스레드가 이 이벤트에 대한 반응을 할 수 있을 때까지 걸리는 시간을 의미한다.**
**그리고 이 시간은 메인 스레드가 처리해야 하는 다른 작업이 많을 수록 느려진다.**

### 기준 점수

- Good: 100ms 이내
- Not Good: 300ms 이내
- Bad: 300ms 이상

### 개선 방안

메인 스레드에 이벤트를 실행할 여유를 줘야 한다.

#### 실행에 오래 걸리는 긴 작업을 분리

긴 작업이 있다면 여러 개로 분리해 처리하는 것이 좋다.
예를 들어 사용자의 액션으로 노출되는 팝업이나 모달의 경우 당장의 로딩에 필요하지 않은 리소스다.
이러한 리소스는 리액트의 Suspense와 lazy를, 혹은 Next.js의 dynamic을 이용해 나중에 불러오게 할 수 있다.

#### 자바스크립트 코드 최소화

번들러가 코드를 만들어주는 과정에서 필요 없는 코드를 제가해 주지만 여진히 웹페이지를 불러오는 데 사용되지 않는 필요 없는 코드가 존재할 수 있다.
개발자 도구의 커버리지를 활용해 이를 확인할 수 있다.

또 한 가지 살펴볼 만한 것은 폴리필이다.
폴리필이란 브라우저에서 지원하지 않는 기능을 사용하기 위해 웹페이지에서 직접 구현하고 집어넣는 코드를 의미한다.
폴리필의 크기는 제법 크기 때문에 폴리필을 집어넣기 전에는 반드시 두 가지를 먼저 확인해 봐야 한다.

1. 폴리필이 필요한 환경인가?
   만약 구형 브라우저 환경을 지원하지 않기로 결심했다면 폴리필을 집어 넣을 필요가 없다.
2. 꼭 필요한 폴리필인가?
   만약 사용하는 곳이 몇 군데 되지 않는 다면 폴리필을 사용하는 것보다 직접 저수준 JS 코드를 작성해 구현하는 편이 코드 크기를 줄이는 데 도움이 될 수 있다.

#### 타사 자바스크립트 코드 실행의 지연

Google Analytics나 Firebase와 같이 웹페이지의 통계 집계를 위해 타사 스크립트를 넣는 경우도 많다.
이 코드의 실행으로 메인 스레드가 잠시 점유되고, 이로 인해 사용자에게 안 좋은 반응성을 제공해서는 안된다.

타사 스크립트는 대부분 웹페이지 로드에 중요한 자원이 아니므로 `<script>`의 async와 defer를 이용해 지연 불러오기를 하는 것이 좋다.

- defer: script에 defer 속성이 있다면 해당 스크립트를 다른 리소스와 함께 병렬로 다운로드한다.
  다운로드 중에도 메인 스레드 작업은 멈추지 않으며, 이 스크립트의 실행은 페이지가 완전히 로딩된 이후에 맨 마지막에 실행된다.
- async: script에 async 속성이 있다면 해당 스크립트를 다른 리소스와 함께 병렬로 다운로드한다.
  async 리소스의 실행 순서는 다운로드가 완료된 순서대로 실행된다.
- 둘 다 없는 경우: script를 만나는 순간 다운로드가 우선되며, 다른 작업은 다운로드와 실행이 끝날 때까지 미뤄진다.

따라서 타사 자바스크립트는 가능하면 async를 더 가능하다면 defer로 지연하는 것이 좋다.

## 12.5 CLS

> 페이지의 생명주기 동안 발생하는 모든 예기치 않은 이동에 대한 지표

### 기준 점수

- Good: 0.1 이하
- Not Good: 0.25 이하
- Bad: 0.25 초과

### 개선 방안

#### 삽입이 예상되는 요소를 위한 추가적인 공간 확보

대부분의 큰 누적 레이아웃 이동은 클라이언트에서 삽입되는 동적인 요소로 인해 발생한다.
또한 요소의 크기가 갑자기 바뀌거나, 뒤늦게 타사 라이브러리가 브라우저에서 로드되는 등의 작업 때문에 나타난다.

useLayotEffect 훅을 사용해 보는 것 또한 검토해 볼만하다.
다만 useLayoutEffect는 동기적으로 발생해 브라우저의 페인팅 작업에 영향을 미치기 때문에 신중하게 선택해야 한다.

스켈레톤 UI를 사용해 동적으로 뜰 것으로 예상되는 공간을 미리 확보해 두는 것도 좋은 방법이다.
그러나 이 역시도 해당 영역이 뜨지 않는 케이스가 있다면 누적 레이아웃 이동을 피하기 어렵다.

가장 좋은 방법은 서버 사이드 렌더링이다.
서버에서 동적인 요소의 유무를 사전에 판단해 클라이언트에 HTML을 미리 제공해 준다면 클라이언트에서는 이러한 고민을 할 필요 없다.

#### 폰트 로딩 최적화

폰트로 인해 발생할 수 있는 문제는 크게 두 가지다.

- FOIT: 폰트를 다운로드하기 전 텍스트 노출 x
- FOUT: 폰트가 다운로드되기 전 기본 폰트 노출 후에 교체

사용자 기기의 기본 폰트 이외에 다른 폰트로 웹페이지를 보여주고 싶다면 다음과 같은 점을 유념해야 한다.

- `<link>`의 preload 사용
  `<link>` 요소의 rel=preload는 페이지에서 즉시 필요로 하는 리소스를 명시하는 기능이다.
  preload로 지정된 요소에 대해 브라우저는 리소스를 더 빠르게 사용할 수 있도록 준비해 준다.
- `font-display`

  - auto: 브라우저가 폰트를 불러오는 방법을 결정
  - block: 폰트가 로딩되기 전까지 최대 3초 간 렌더링을 중단한다. (FOIT)
  - swap: 기본 폰트로 글자를 렌더링한 다음 폰트의 로딩이 완료되면 적용한다. (FOUT)
  - fallback: 0.1초간 block 후 기본 폰트를 보여준다. 3초 이내 폰트가 로딩된다면 전환한다. (block + swap)
  - optional: fallback과 매우 유사하며 네트워크 상태에 따라 웹 폰트 로드를 아예 무시할 수 있다.

#### 적절한 이미지 크기 설정

```css
img {
  width: 100%;
  height: auto;
}
```

위 css는 기기의 너비가 어떻게 되든 원본 이미지의 가로세로 비율이 일정해 사용자에게 최적의 이미지를 보여줄 수 있다는 장점이 있다.
그러나 이미지의 높이를 명확하게 알지 못하기 때문에 레이아웃 이동이 크게 발생한다는 단점이 있다.

- width, height 지정
  위 css 코드와 함께 width와 height를 원하는 비율로 지정하면 브라우저가 이미지를 로딩하기 전에 적절한 가로세로 비율을 계산해 이미지가 표시되는 만큼 면적을 할당해 둔다.
- 사용자 뷰포트 너비에 맞춰 다른 이미지를 제공하는 경우 srcset 속성을 사용하는 것이 좋다.
  ```html
  <img
    width="1000"
    height="1000"
    src="image-1000.jpg"
    srcset="image-1000.jpg 1000w, image-2000.jpg 2000w, image-3000.jpg 3000w"
    alt="이미지"
  />
  ```

## 12.6 핵심 웹 지표는 아니지만 성능 확인에 중요한 지표들

### TTFB

> 브라우저가 웹페이지의 첫 번째 바이트를 수신하는데 걸리는 시간

서버 사이드 렌더링을 하고 있는 애플리케이션에서 주의 깊게 봐야 할 지표

### FCP

> 페이지가 로드되기 시작한 시점부터 페이지 콘텐츠의 일부가 화면에 렌더링될 때까지의 시간

### 기준 점수

- Good: 1.8초 이내
- Not Good: 3초 이내
- Bad: 3초 이상

### 개선 방안

- TTFB 개선
- 렌더링을 가로막는 리소스 최소화
- 페이지 리다이렉트 최소화
- DOM 크기 최소화

---

### 새로 알게된 개념

- 핵심 웹 지표
