# 8. 좋은 리액트 코드 작성을 위한 환경 구축하기

**좋은 코드를 작성하기 위한 ESLint와 리액트 테스트 라이브러리를 알아보자**

<br>

## 8.1 ESLint를 활용한 정적 코드 분석

### ✨ JS 생태계에서 가장 많이 사용되는 정적 코드 분석 도구 ESLint에 대해 알아봅세~

<br>

### 8.1.1 ESLint 살펴보기

---

### 🔖 ESLint 어떻게 이렇게 쌈@뽕하게 JS 코드를 분석하는 걸까?

- JS코드를 문자열로 읽는다.

- JS 코드를 분석 가능한 파서(parser)로 코드를 구조화한다.

- 구조화한 AST(Abstract Syntax Tree)라 하고, 이를 각종 규칙과 대조한다.

- 규칙 위반 코드를 알리거나 수정한다.

### 🖥️ 코드 변환 톺아보기

```jsx
const handleCancelClick = () => {
  setIsEditing(false);
  setRenewalTime(!renewalTime);
  cancelModalOff();
  updateFormData();
};
```

```js
{
  "type": "Program",
  "start": 0,
  "end": 322,                 // 코드 시작
  "body": [
    {
      "type": "VariableDeclaration",
      "start": 181,
      "end": 322,
      "declarations": [
        {
          "type": "VariableDeclarator",
          "start": 187,                   // const 뺀 나머지
          "end": 321,
          "id": {
            "type": "Identifier",
            "start": 187,
            "end": 204,                     // 함수 이름
            "name": "handleCancelClick"
          },
          "init": {
            "type": "ArrowFunctionExpression",
            "start": 207,                     // 화살표 함수임을 의미
            "end": 321,
            "id": null,
            "expression": false,
            "generator": false,
            "async": false,
            "params": [],
            "body": {
              "type": "BlockStatement",
              "start": 213,
              "end": 321,                     // {} 블록 스테이트 시작
              "body": [
                {
                  "type": "ExpressionStatement",
                  "start": 219,
                  "end": 239,
                  "expression": {
                    "type": "CallExpression",
                    "start": 219,
                    "end": 238,
                    "callee": {
                      "type": "Identifier",
                      "start": 219,
                      "end": 231,
                      "name": "setIsEditing"    // setIsEditing 실행 부분
                    },
                    "arguments": [
                      {
                        "type": "Literal",
                        "start": 232,
                        "end": 237,
                        "value": false,
                        "raw": "false"
                      }
                    ],
                    "optional": false
                  }
                },
                {
                  "type": "ExpressionStatement",
                  "start": 244,
                  "end": 273,
                  "expression": {
                    "type": "CallExpression",
                    "start": 244,
                    "end": 272,
                    "callee": {
                      "type": "Identifier",
                      "start": 244,
                      "end": 258,
                      "name": "setRenewalTime"      // setRenewalTime 실행 부분
                    },
                    "arguments": [
                      {
                        "type": "UnaryExpression",
                        "start": 259,
                        "end": 271,
                        "operator": "!",
                        "prefix": true,
                        "argument": {
                          "type": "Identifier",
                          "start": 260,
                          "end": 271,
                          "name": "renewalTime"     // setRenewalTime에 들어간 인수
                        }
                      }
                    ],
                    "optional": false
                  }
                },
                {
                  "type": "ExpressionStatement",
                  "start": 278,
                  "end": 295,
                  "expression": {
                    "type": "CallExpression",
                    "start": 278,
                    "end": 294,
                    "callee": {
                      "type": "Identifier",
                      "start": 278,
                      "end": 292,
                      "name": "cancelModalOff"          // cancelModalOff 실행 부분
                    },
                    "arguments": [],
                    "optional": false
                  }
                },
                {
                  "type": "ExpressionStatement",
                  "start": 300,
                  "end": 317,
                  "expression": {
                    "type": "CallExpression",
                    "start": 300,
                    "end": 316,
                    "callee": {
                      "type": "Identifier",
                      "start": 300,
                      "end": 314,
                      "name": "updateFormData"            // updateFormData 실행 부분
                    },
                    "arguments": [],
                    "optional": false
                  }
                }
              ]
            }
          }
        }
      ],
      "kind": "const"
    }
  ],
  "sourceType": "module"
}
```

### 📚 `espree` 코드 분석 결과를 바탕으로 ESLint가 뭘 수정하고 변경할지 결정

```js
module.export = {
  meta: {
    type: "problem",
    docs: {
      description: "Disallow the use of `debugger`",
      recommended: true,
    },
    fixable: null, // 코드 수정 불가
    schema: [], // 옵션 미설정
  },
  create(context) {
    // 실제 코드에서 문제점 확인
    return {
      DebuggerStatement(node) {
        context.report({
          // debuggerStatement 확인 후 리폿
          node,
          message: "Unexpected 'debugger' statement.",
          fix: function (fixer) {
            return fixer.remove(node);
          },
        });
      },
    };
  },
};
```

<br>

### 8.1.2 eslint-plugin과 eslint-config

---

- `eslint-plugin` 은 언급했던 규칙들을 모아놓은 패키지이며, 대시(-)를 뒤에 붙여 다양한 상황에 해당하는 규칙들을 제공한다.

```bash
eslintrc
├─ conf
│  ├─ config-schema.js
│  └─ environments.js
├─ dist
│  ├─ eslintrc-universal.cjs
│  ├─ eslintrc-universal.cjs.map
│  ├─ eslintrc.cjs
│  └─ eslintrc.cjs.map
├─ lib
│  ├─ config-array
│  │  ├─ config-array.js
│  │  ├─ config-dependency.js
│  │  ├─ extracted-config.js
│  │  ├─ ignore-pattern.js
│  │  ├─ index.js
│  │  └─ override-tester.js
│  ├─ shared
│  │  ├─ ajv.js
│  │  ├─ config-ops.js
│  │  ├─ config-validator.js
│  │  ├─ deprecation-warnings.js
│  │  ├─ naming.js
│  │  ├─ relative-module-resolver.js
│  │  └─ types.js
│  ├─ cascading-config-array-factory.js
│  ├─ config-array-factory.js
│  ├─ flat-compat.js
│  ├─ index-universal.js
│  └─ index.js
├─ LICENSE
├─ package.json
├─ README.md
└─ universal.js
```

- `eslint-config` 는 위의 `eslint-plugin` 의 묶음 판매 패키지라고 볼 수 있으며, 이는 여러 프로젝트에 걸쳐 동일하게 사용 가능한 ESLint 관련 설정을 제공한다.

```js
{
  "parser": "@typescript-eslint/parser",
  "extends": [
    "next/core-web-vitals",
    "next",
    "eslint:recommended",
    "plugin:import/recommended",
    "plugin:import/typescript",
    "plugin:@typescript-eslint/recommended",
    "plugin:react-hooks/recommended",
    "plugin:tailwindcss/recommended",
    "prettier"
  ],
  "plugins": ["import", "@typescript-eslint", "react-hooks", "tailwindcss", "prefer-arrow"],
  "rules": {
    "import/order": [
      "error",
      {
        "groups": [
          "external", // 외부 라이브러리
          "builtin", // Node.js 내장 모듈
          "internal", // 경로 별칭 (@)
          "parent", // 부모 경로 (..)
          "sibling", // 같은 경로 (./)
          "index", // 현재 디렉토리 (./)
          "object"
        ],
        "pathGroups": [
          {
            "pattern": "react*",
            "group": "external",
            "position": "before"
          }
        ],
        "pathGroupsExcludedImportTypes": ["react*"]
      }
    ],
    "arrow-body-style": ["error", "always"],
    "curly": ["error"],
    "max-depth": ["error", 4],
    "import/export": "warn",
    "react/react-in-jsx-scope": "off",
    "prefer-arrow/prefer-arrow-functions": [
      "error",
      {
        "disallowPrototype": true,
        "singleReturnOnly": false,
        "classPropertiesAllowed": false
      }
    ]
  },
  "settings": {
    "import/resolver": {
      "typescript": true
    }
  }
}
```

### 👍 원래 직접 만드는 것보다 남이 해준 요리가 더 맛있다.

- 개발자가 직접 패키지를 짜는 경우는 거의 없고, 일부 IT 기업에서 만들어둔 템플릿들을 활용하는 느낌으로 많이 사용한다.

### 개추! (개발자 추천)

- `eslint-config-airbnb`

  - 가장 대중적인 `eslint-config` 템플릿이다.

- `titicaca/tripole-config-kit`

  - 유지보수가 활발한 편에 속하는 `config` 이며, airbnb의 `config` 를 기반으로 하지 않는데도 불구하고 왠만한 규칙을 제공하여 사용 시 큰 지장이 없다.

  - 또한 외부 제공 규칙에 대한 테스트 코드가 존재하여 각 환경에 맞게 사용할 수 있다.

- `eslint-config-next`

  - `Next.js` 를 이용한 프로젝트는 그냥 이놈 쓰자.

<br>

### 8.1.3 나만의 ESLint 규칙 만들기

---

### 🔖 나만의 ESLint 규칙을 만들어 나에게 가장 익숙한 규칙으로 코드를 작성하자

- 이미 존재하는 규칙을 커스터마이징하여 적용하는 것은 매우 유용하다.

```js
// no improt react
module.exports = {
  rules: {
    'no-restricted-imports' : [
      'error',
      {
        path: [
          {
            name: 'react',
            importNames: ['default'] // import react만 제외하기 위함
            message: '이제부턴 import react는 안해도 돼!'
          }
        ]
      }
    ]
  }
}
```

- 아예 새로운 나만의 규칙을 만들 수도 있다.

```js
// new Date 금지하기
module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "Disallow use of `new Date()` without arguments",
      category: "Possible Errors",
      recommended: false,
    },
    fixable: "code", // 코드 수정 가능
    schema: [], // 옵션 미설정
  },
  create(context) {
    return {
      NewExpression(node) {
        if (node.callee.name === "Date" && node.arguments.length === 0) {
          // 코드 객체의 이름이 Date임과 동시에 인수의 길이가 0일 경우
          context.report({
            node,
            message: "Use of `new Date()` without arguments is not allowed.",
            fix: function (fixer) {
              // 자동 수정: `new Date()`를 `new Date(/* specify arguments */)`로 변경
              return fixer.replaceText(node, "new Date(/* specify arguments */)");
            },
          });
        }
      },
    };
  },
};
```

### 📂 만든 규칙들을 배포해보자!

- 먼저 `yo`와 `generate-eslint` 를 활용해 `eslint-plugin` 구성 환경을 만든다.

- 구성된 디렉토리 및 파일에서 `rules/no-new-date.js` 파일을 열고 앞에서 작성한 규칙을 붙여넣는다.

- `npm publish` 로 배포하고 원하는 프로젝트에 설치 및 사용한다.

<br>

### 8.1.4 주의할 점

---

### 🔖 잘못 설정하면 원치 않는 결과가 나온다.

- 코드의 포메팅을 돕는 `Prettier` 과의 충돌이 일어날 수 있으므로 항상 주의해야 한다.

  - 서로 충돌하지 않게끔 규칙을 잘 설정한다.

  - JS, TS는 ESLint에 맡기고, 그 외는 `Prettier` 에 맡긴다.

- 특정 규칙을 임시로 제외하고 싶은 경우 `react-hooks/no-exhaustive-deps` 주석을 사용한다.

  - 모든 규칙은 존재하는 이유가 있으니까 핑계대지 말고 잘 점검하고 사용하자

- ESLint 버전이 충돌하여 문제가 생길 수 있다.

  - 설치하고자 하는 `config` 밑 `plugin` 및 프로젝트가 지원하는 버전을 잘 확인해야한다.

<br>

### 8.1.5 책 정리 + 주관적인 정리

### 🔖 책 정리

- ESLint는 개발자의 숟가락과도 같다.

- 잘 정리된 규칙을 사용하거나 직접 커스텀하는 등 자유도가 높지만 그만큼 알맞게 사용해야 한다.

- 익숙해진다면 본인만의 `eslint-config`를 만들어보는 것도 큰 도움이 될 것이다.

### 🏷️ 주관적인 정리

- ESLint는 항상 가까이 있으나 막상 보면 어색한 친구라고 생각한다.

- ESLint의 규칙들은 모두 존재하는 이유가 있으므로, 항상 신경쓰며 잘 사용하자.
