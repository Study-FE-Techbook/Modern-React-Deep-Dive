# 5. 리액트와 상태 관리 라이브러리

**상태 관리는 왜 필요하고 어떻게 작동하는가**

<br>

## 5.1 상태 관리는 왜 필요한가?

### ✨ 웹 내부에서 상태란 어떠한 의미를 지니고 지속적으로 변경되는 값을 의미

- 상태는 웹의 발전에 따라 다양해지고 있으며 이를 효율적으로 관리하는 방법을 고민해야 한다.

<br>

### 5.1.1 리액트 상태 관리의 역사

---

### 🔖 Flux 패턴의 등장

- `Context API` 가 나오기 전까지는 이렇다할 상태관리에 관련된 기능이 없었다.

- 웹 앱이 발전함에 따라 복잡성이 증가했고, 이러한 문제의 원인이 '양방향 바인딩' 으로 귀결되었다.

  ❗뷰(HTML)과 모델(JS) 서로가 서로를 변경 가능하여 데이터의 복잡성과 관리 난이도가 증가

<br>

- 때문에 이를 완화하고자 단방향 데이터의 흐름을 제안하였다. (Flux 패턴)

![alt text](image.png)

- 액션(action) : 작업 처리 액션 및 액션에 포함할 데이터, 각각 정의하여 디스패치로 보냄

- 디스패처(dispatcher) : 액션을 스토어로 보내는 역할, 콜백 함수 형태로 액션 관련 요소를 스토어로 보냄

- 스토어(store) : 실제 상태에 따른 값과 상태 변경 메서드 보유, 액션 타입에 따라 변경 여부 정의

- 뷰(view) : 컴포넌트에 해당하는 부분, 스토어의 데이터를 통해 화면 렌더링 및 자체적인 액션 호출을 통해 상태 업데이트 또한 가능

<br>

☝️ 물론 사용자 입력에 따른 상태 갱신과 코드의 양 증가로 수고로운 점은 존재

### ✋ BUT!!

👍 데이터가 한방향으로 흐르므로 추적이 쉽고 코드 이해가 용이

<br>

### 🔖 시장 지배자 리덕스의 등장

- Flux가 리액트를 씹어먹을 무렵 얍삽하게 Flux 구조 표현 및 Elm 아키텍쳐 도입으로 시장 선점

```jsx
// 액션은 상태 변경을 위한 정보를 담고 있는 객체
export const increment = () => {
  return {
    type: "INCREMENT",
  };
};

export const decrement = () => {
  return {
    type: "DECREMENT",
  };
};

const initialState = {
  count: 0,
};

// 리듀서는 액션을 기반으로 새로운 상태를 반환하는 함수
const counterReducer = (state = initialState, action) => {
  switch (action.type) {
    case "INCREMENT":
      return {
        ...state,
        count: state.count + 1,
      };
    case "DECREMENT":
      return {
        ...state,
        count: state.count - 1,
      };
    default:
      return state;
  }
};

// 스토어는 리덕스 상태 트리를 담고 있는 객체
import { createStore } from "redux";
import counterReducer from "./reducer";

const store = createStore(counterReducer);

export default store;
```

- 모델(상태)와 뷰(HTML), 업데이트(모델 수정)의 콜라보

- `Elm` 은 데이터 흐름을 세가지로 분류 및 단방향으로 강제해 상태를 안정적으로 관리 유도

- 글로벌 상태 객체를 통해 `props drilling` 를 해결하고 간단한 상태 접근이 가능해 많은 사랑을 받았다. (현재진행형)

❗하지만 하나의 상태 관리만으로도 수행해야 할 작업이 너무 많았다.

<br>

### 🔖 Context API, useContext

- 너무 복잡했던 리덕스를 대체하기 위해 리액트에서 자체적으로 개발한 상태 주입용 API

```jsx
import React, { createContext, useState } from "react";

// Context 생성
export const ThemeContext = createContext();

// Context Provider 정의
export const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState("light");

  const toggleTheme = () => {
    setTheme((prevTheme) => (prevTheme === "light" ? "dark" : "light"));
  };

  return <ThemeContext.Provider value={{ theme, toggleTheme }}>{children}</ThemeContext.Provider>;
};

// Provider 사용
const App = () => {
  return (
    <ThemeProvider>
      <div>
        <ThemeToggler />
        <ThemeDisplay />
      </div>
    </ThemeProvider>
  );
};

// Context 사용
const ThemeToggler = () => {
  const { theme, toggleTheme } = useContext(ThemeContext);

  return <button onClick={toggleTheme}>Toggle to {theme === "light" ? "dark" : "light"} theme</button>;
};
```

- `props drilling` 을 효과적으로 방지하지만 결국 상태 관리에 목적을 두지 않기 때문에 사용 시 유의해야한다.

<br>

### 🔖 훅의 탄생과 React Query, SWR

- 훅과 함수형 컴포넌트의 간단한 상태값 관리에 따라 상태 관리 라이브러리 또한 변화했다.

- 이 중 가장 각광받은 것이 바로 `React Query` 와 `SWR` 이다.

```jsx
const { data, isLoading, isError } = useQuery({
  queryKey: ["test"],
  queryFn: getTestData,
});

// 로딩중
if (isLoading) {
  return <div>Loading...</div>;
}

// 에러
if (isError) {
  return <div>Error fetching data</div>;
}

const postWriteData = async () => {
  // 생략
};

const mutation = useMutation({
  mutationFn: postWriteData,
  onMutate() {
    console.log("mutation 실행 전");
  },
  onSuccess(data) {
    console.log(data);
  },
  onError(err) {
    console.error(err);
  },
  onSettled() {
    console.log("finally 처럼 마지막에 실행");
  },
});
```

- `React Query` 의 경우, `useQuery` 와 `useMutation` 을 통해 데이터 페칭과 더불어 해당 상태값을 간결하고 효율적으로 관리

<br>

### 🔖 Recoil, Zustand, Jotai, Valtio 에 이르기까지

- 훅을 활용해 상태를 가져오고 관리하는 다양한 라이브러리

<br>

### 최근 각광받는 `Zustand`에 대해 알아보자

- 표면적으로 인기있는 이유는 API가 간단하며, 효율적으로 리렌더링하고 미들웨어를 지원한다.

```jsx
// src/store.js
import create from "zustand";

const useStore = create((set) => ({
  count: 0,
  increase: () => set((state) => ({ count: state.count + 1 })),
  decrease: () => set((state) => ({ count: state.count - 1 })),
}));

export default useStore;

// src/App.js
import React from 'react';
import useStore from './store';

const Counter = () => {
  const { count, increase, decrease } = useStore();

  return (
    <div>
      <h1>{count}</h1>
      <button onClick={increase}>Increase</button>
      <button onClick={decrease}>Decrease</button>
    </div>
  );
};

const App = () => {
  return (
    <div>
      <h1>Zustand Counter Example</h1>
      <Counter />
    </div>
  );
};

export default App;
```

<br>

### 5.1.2 책 정리 + 주관적인 정리

---

### 🔖 책 정리

- 상태 관리 라이브러리를 잘 뜯어본다면 더욱 성장할 수 있는 계기가 될 것이다.

### 🏷️ 주관적인 정리

- 단순히 상태 관리 라이브러리에 대해 막연히 알고만 있었는데, 이번 계기로 조금 더 자세하게 알 수 있어서 좋았다.

- 함수형 컴포넌트와 훅에 등장에 따라 변화한 상태 관리 라이브러리의 동작 원리와 로직에 대한 흥미가 생겼다.

<br>

## 5.2 리액트 훅으로 시작하는 상태 관리

### ✨ 함수 컴포넌트의 패러다임과 더불어 내부 상태 관리에 용이한 라이브러리를 알아보자

<br>

### 5.2.1 가장 기본적인 방법 : useState와 useReducer

---

- `useState` 를 활용한 갖가지 커스텀 훅을 통해 내부(지역) 상태 관리를 쉽고 안정적으로 할 수 있게 되었다.
