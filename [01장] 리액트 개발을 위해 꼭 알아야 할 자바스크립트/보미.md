# 리액트 책 속으로 들어가며…🥹

## 리액트 왜 씀?

왜 리액트가 지난 몇 년간 많은 개발자들이 선호하는 라이브러리가 됐을까?

- **단방향 바인딩**
  만약 양방향으로 바인딩되면 뷰의 변화가 컴포넌트에 영향을 미칠 수도, 반대로 컴포넌트의 상태가 변경되면 뷰의 상태도 변할 수 있다. 리액트는 단방향 바인딩을 통해 상태 변화를 감지하고 업데이트한다.
- JSX
- 배우기 쉽고 간결함
- 활발한 커뮤니티 활성화

# [1장] 리액트 개발을 위해 꼭 알아야 할 자바스크립트

## 1.1 자바스크립트의 동등 비교

리액트의 가상 DOM과 실제 DOM의 비교, 리액트 컴포넌트가 렌더링하지 판다하는 방법, 변수나 함수의 메모이제이션 등 모든 작업은 자바스크립트의 동등 비교를 기반으로 한다.

리액트 컴포넌트의 렌더링이 일어나는 이유 중 하나가 바로 props의 동등 비교때문이다. props의 동등 비교는 객체의 얕은 비교를 기반으로 이뤄진다.

### 📍자바스크립트 데이터 타입

**✨원시타입**

> 메서드를 갖지 않는다.

- undefined: 선언됐지만 할당되지 않은 값
- null: 명시적으로 비어 있음을 나타내는 값
  💡typeof로 null을 확인하면 object가 반환된다. (초창기 JS가 값을 표현하는 방식 때문에 null로 표현하려 했지만 호환성이 깨져 받아들여지지 않음)
- boolean
- number
- bigInt: number가 다룰 수 있는 숫자 크기의 제한을 극복
  💡bigInt를 number로 변환하면 데이터 손실 가능성이 있음
      ```jsx
      // BigInt를 만드는 방법
      let bigInt1 = BigInt(1234567890123456789012345678901234567890n);
      let bigInt2 = 1234567890123456789012345678901234567890n; // 끝에 'n'을 붙여서 선언

      // number와 BigInt 비교
      let bigInt = 12345678901234567890n;
      let number = 12345678901234567890;

      console.log(bigInt == number); // true
      console.log(bigInt === number); // false
      ```
- string
  💡문자열은 변경 X
      ```jsx
      const name = '보미'
      name[1] = '파'
      console.log(name) // 보미
      ```
- symbol: 중복되지 않는 고유한 값
  ```jsx
  const key = Symbol('key')
  const key2 = Symbol('key')

  console.log(sym1 === sym2) // false

  // Symbol.for
  const sym1 = Symbol.for('sharedSymbol')
  const sym2 = Symbol.for('sharedSymbol')

  // 같은 키로 생성된 심볼은 동일함
  console.log(sym1 === sym2) // true
  ```

**✨객체 타입**

> 참조를 전달한다고 해서 참조 타입이라고도 불림

```jsx
const bomi = function () {}
const bopa = bomi // bomi와 동일한 함수 객체를 참조(복붙 느낌)

// 동일한 메모리 주소 참조
console.log(bomi === bopa) // true
```

```jsx
const bomi = function () {}
const bopa = function () {}

// 서로 다른 메모리 주소를 참조
console.log(bomi === bopa) // false
```

### 📍자바스크립트의 또 다른 비교 공식 Object.is

> 두 개의 인수가 동일한지 확인하고 반환하는 메서드

=== 연산자와 비슷하게 작동하지만 NaN과 -0을 다루는 방식에서 차이가 있음

>

💡==: 같음을 비교하기 전에 양쪽이 같은 타입이 아니라면 비교할 수 있도록 강제로 형변환 한 후 비교한다.

```jsx
console.log(NaN === NaN) // false
console.log(Object.is(NaN, NaN)) // true

console.log(-0 === +0) // true
console.log(Object.is(-0, +0)) // false
```

```jsx
// 숫자 비교
console.log(Object.is(25, 25)) // true
console.log(Object.is(25, '25')) // false

// 객체 비교
const obj1 = { a: 1 }
const obj2 = { a: 1 }
const obj3 = obj1

console.log(Object.is(obj1, obj2)) // false (서로 다른 객체)
console.log(Object.is(obj1, obj3)) // true (같은 객체를 참조)

// 문자열 비교
console.log(Object.is('hello', 'hello')) // true
console.log(Object.is('hello', 'world')) // false

// 특별한 값 비교
console.log(Object.is(NaN, NaN)) // true
console.log(Object.is(0, -0)) // false
console.log(Object.is(-0, -0)) // true
```

### 📍리액트에서의 동등 비교

리액트는 Object.is를 폴리필과 함께 사용해 일관된 동등 비교를 한다. 모든 브라우저가 Object.is를 지원하지 않을 수 있어 폴리필을 사용해 해당 기능을 지원한다.

> **❓폴리필**
> 최신 웹 기술을 이전 브라우저에서도 사용할 수 있게 해주는 도구

리액트는 이 Object.is를 기반으로 동등 비교를 하는 shallowEqual이라는 함수를 만들어 사용한다. 상태(state)나 속성(props)을 비교할 때 사용한다. 그래서 값과 타입이 정확히 같은지 확인할 수 있고, 이전 상태나 속성과의 비교를 안전하게 수행할 수 있다. 특히, React.memo나 useMemo 등 최적화 기능을 사용할 때 Object.is를 사용해 얕은 비교로 불필요한 리렌더링을 방지할 수 있다.

리액트는 Object.is로 먼저 비교를 수행한 후, 객체 간 얕은 비교를 한 번 더 수행한다.

```jsx
// Object.is는 참조가 다른 객체에 대해 비교가 불가능
Object.is({ hello: 'bomi' }, { hello: 'bomi' }) // false

// shallowEqual은 객체의 1 depth까지는 비교 가능
shallowEqual({ hello: 'bomi' }, { hello: 'bomi' }) // true

// 2 depth까지 가면 비교할 방법이 없어 false 반환
shallowEqual({ hello: { hi: 'bomi' } }, { hello: { hi: 'bomi' } }) //false
```

> **❓왜 얕은 비교까지만 구현했을까**
> 리액트는 props만 일차적으로 비교하면 되기 때문.
> 리액트는 props에서 꺼내온 값만 기준으로 렌더링을 수행하기 때문에 일반적인 케이스에서는 얕은 비교로 충분하다.

## 1.2 함수

> 함수: 작업을 수행하거나 값을 계산하는 등의 과정을 표현하고, 하나의 블록으로 감싸 실행 단위로 만들어 놓은 것

**✨함수 선언식**

```jsx
function add(x, y) {
  return x + y
}
```

**✨함수 표현식**

> 💡일급 객체: 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체

**자바스크립트에서 함수는 일급 객체임**

>

```jsx
const add = function (x, y) {
  return x + y
}
```

**🔥함수 선언식과 함수 표현식 차이**

> 💡호이스팅: 변수 및 함수 선언을 컨텍스트 상단으로 옮겨지는 것

- 함수 선언식은 호이스팅 O
- 함수 표현식은 호이스팅 X

```jsx
// 함수 선언식
add(2, 3) // 호출 가능

function add(x, y) {
  return x + y
}

// 함수 표현식
subtract(5, 3) // 에러: TypeError: subtract is not a function

const subtract = function (x, y) {
  return x - y
}
```

### **🔥화살표 함수의 차이**

1.  Constructor를 사용할 수 없다.
2.  arguments가 존재하지 않는다.
3.  자신의 this를 가지지 않는다. 언제나 상위 스코프의 this를 상속받는다.
    💡this: 자신이 속한 객체나 자신이 생성할 인스턴스를 가리키는 값
    💡일반함수는 호출될 때마다 this가 동적으로 결정된다.
        ```jsx
        const obj = {
          name: 'bomi',
          greet: function() {
            console.log(`Hello, ${this.name}!`);
          },
          greetArrow: () => {
            console.log(`Hello, ${this.name}!`);
          }
        };

        obj.greet(); // Hello, bomi! (일반 함수 내부의 this는 해당 객체를 참조)
        obj.greetArrow(); // Hello, undefined! (화살표 함수 내부의 this는 상위 스코프의 this를 가리킴)
        ```

### 📍다양한 함수 살펴보기

**✨즉시 실행 함수**: 함수를 정의하고 그 순간 즉시 실행되는 함수

```jsx
;(function (a, b) {
  return a + b
})(10, 24) // 34
```

**✨고차 함수**: 함수를 인수로 받거나 결과로 새로운 함수를 반환시키는 역할

```jsx
//함수를 매개변수로 받는 대표적 고차함수: Array.prototype.map
const doubleArray = [1, 2, 3].map((item) => item * 2)

doubleArray // [2, 4, 6]
```

### 📍함수를 만들 때 주의해야 할 사항

- 함수의 부수효과를 최대한 억제하기
- 가능한 한 함수를 작게 만들기
- 누구나 이해할 수 있는 이름 붙이기

---

리액트는 왜 얕은 복사를 하는가?

코드 1.1과 1.3 이해가 안 감…ㅎㅎㅎ
