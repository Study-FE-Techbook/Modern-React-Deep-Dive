#

# 13장 웹페이지의 성능을 측정하는 다양한 방법

## 13.1 애플리케이션에서 확인하기

### 13.1.1 create-react-app

- web-vitals 라이브러리
  - PerformanceObserver API 사용
  - 웹페이지에서 다양한 성능 측정할 수 있는 API

### 13.1.2 create-next-app

- 성능 측정 메서드 NextWebVItalsMetric
- Next.js에 특화된 사용자 지표
- `Next.js-hydration` : 페이지가 서버 사이드에서 렌더링되어 하이드레이션하는 데 걸린 시간
- `Next.js-route-change-to-render` : 페이지가 경로를 변경한 후 페이지를 렌더링을 시작하는 데 걸리는 시간
- `Next.js-render` : 경로 변경이 완료된 후 페이지를 렌더링하는 데 걸린 시간

## 13.2 구글 라이트하우스

- 구글에서 제공하는 웹 페이지 성능 측정 도구
- 접근성 PWA, SEO 등도 측정 및 점검
- 실행 방법
  - 사이트 방문 후 크롬 개발자 도구에서 Lighthouse 탭 선택

### 13.2.1 구글 라이트하우스 - 탐색 모드

- 페이지에 접속했을 때부터 페이지 로딩이 완료될 때까지의 성능을 측정하는 모드

📍 성능

- 웹페이지 성능과 관련된 지표
- FCP, LCP, CLS 외 추가적인 지표
- `Time to Interactive` TTI
  - 페이지에서 사용자가 완전히 상호작용할 수 있을 때까지 걸리는 시간
  - FCP로 측정되는 페이지 내 콘텐츠가 표시되는 시점
  - 보여지는 페이지 요소의 대부분에 이벤트 핸들러가 부착되는 시점
  - 페이지가 유저의 상호작용에 50ms 내로 응답하는 시점
  - 3.8초 이내 좋음 , 7.3초 이내 보통, 그 이후 개선 필요
- `Speed Index`
  - 페이지가 로드되는 동안 콘텐츠가 얼마나 빨리 시각적으로 표시되는지 계산
  - 로드되는 페이지를 실시간으로 캡쳐하고 이를 분석하여 계산함
  - 3.4초 이내 좋음, 5.8초 이내 좋음, 그 이후 느림
- `Total Blocking Time`
  - 메인 스레드에서 특정 시간 이상 실행되는 작업, 즉 긴 작업이 수행될 때마다 메인 스렌드가 차단됐다고 간주
  - 그동안 다른 작업 실행할 수 없기 때문
  - FCP부터 TTI 사이의 긴 작업들의 시간에서 50ms 빼고 이를 모두 합해 계산
  - 사용자가 무언가 작업이 진행되고 있지 않다는 걸 눈치 챌 수 있는 시간을 대상

📍 접근성

- 장애인 및 고령자 등 신체적으로 불편한 사람들이 일반적인 사용자와 동등하게 웹페이지를 이용할 수 있도록 보장하는 것

📍 권장사항

- 웹사이트를 개발할 때 고려해야 할 요소들을 얼마나 지키고 있는지
- CSP가 XSS 공격에 효과적인지 확인
  - XXS (Cross Site Scripting)
  - 개발자가 아닌 제3자가 삽입합 스크립트를 통해 공격하는 기법
  - CSP (Content Security Policy)
  - 웹사이트에서 호출할 수 있는 컨텐츠를 제한하는 정책
- 감지된 JS 라이브러리
- HTTPS 사용
- 페이지 로드 시 위치정보/알림 권한 요청 방지하
  - 사용자 동의 없이 실행되는지 확인
- 알려진 보안 취약점이 있는 FE JS 라이브러리 사용하지 않음
- 비밀번호 입력란 붙여넣기 허용
  - 붙여넣기 가능해야 함
- 이미지 - 가로세로 비율, 적절한 해상도
- HTML Docutype
  - 없으면 표준을 준수하지 않은 것으로 간주하여 호환 모드로 렌더링되기 때문
- 적절한 charset 정의
- 지원 중단 API 사용하지 않긱
- 콘솔에 로그된 브라우저 오류 없음

📍 검색 엔진 최적화

- 검색엔진이 쉽게 웹페이지 정보를 가져가서 공개할 수 있도록 최적화돼 있는지 확인

### 13.2.2 구글 라이트하우스 - 기간 모드

- 실제 웹페이지를 탐색하는 동안 지표 측정
- 사용자가 빈번하게 수행할 작업들을 측정하면 성능 최적화에 도움

📍 흔적 (View Trace)

- 시간의 흐름에 따라 어떻게 웹페이지가 로딩됐는지

📍 트리맵

- 페이지를 불러올 때 함께 로딩한 모든 리소스
- 실제 불러온 데이터의 크기 확인
- 실제 불러왔지만 사용되지 않은 리소스 확인

### 13.2.3 구글 라이트하우스 - 스냅샷

- 탐색 모드와 유사, 현재 페이지 상태를 기준으로 분석

## 13.3 WebPageTest

- 웹사이트 성능 분석
- 글로벌 웹사이트 분석에 적합
- Site Performence : 웹사이트 성능 분석
- Core Web Vitals : 핵심 웹 지표 확인
- Lighthouse
- Visual Comparison : 2개 이상 사이트를 동시에 실행에 시간의 흐름에 따른 로딩 과정 분석
- Traceroute : 네트워크 경로 확인

### 13.3.1 Performance Summary

- Opportunities & Experiments
  - Is it Quick : 웹사이트 빠른지 평가 ,TTFB, LCP 등 판단
  - Is it Usable : 사용성과 시각적인 요소 확인, CLS, 접근성 이슈 등
  - Is it Resilent : 보약 취약성 점검

### 13.3.2 Opportunities & Experiments

- TTFB 점검
- 렌더링을 막는 JS 가 있는지(적을 수록 렌더링 수월)
- 렌더링 막는 CSS 확인
- 주요 영역 내 게으른 로딩 이미지가 적을 수록, 주요 영역 외에는 게으른 로딩 이미지 적용이 좋음
- 최초 다운 받은 HTML과 최종 결과물 HTML 사이에 크기 차이가 작아야 함
  - 차이가 크다 : 최종 결과물을 그리기 위해 JS가 많이 사용되었다를 의미

### 1.3.3 Filmstrip

- 시간의 흐름에 따라 어떻게 웹사이트가 그려졌으며 어떤 리소스가 불러와졌는지 확인
- 렌더링을 가로막는 리소스와 예상보다 일찍 실행되는 스크립트 확인 가능

### 1.3.6 Optimizations

- 리소스들이 얼마나 최적화돼 있는지 나타냄
- Keep-Alive 설정으로 서버와의 연결 계속 유지하는지
- 이미지를 적절하게 압축했는지
- 리소스가 CDN을 거치는지

### 13.3.8 Domains

- 중요 리소스는 웹사이트와 같은 곳에서 요청할 수록 도메인 연결에 소요되는 비용을 줄일 수 있음

### 13.3.9 Console Log

- 사용자가 접속했을 때 console.log가 무엇이 기록됐는지 확인
- console.log 자체도 부하가 발생하는 작업이기에 사용 지양

## 13.4 크롬 개발자 도구

### 13.4.1 성능 통계

📍Insights

- 성능 측정 중 살펴봐야 할 이벤트 보여줌
  - Performance Measure
  - Long Task : 메인 스레드에서 오랜 시간동안 실행된 긴 작업
  - Forced Style recalculation
    - 스타일이 한 번 계산된 이후 스타일이 다시 강제로 계산되는 작업 실행
    - 이는 리소스가 많이 소요되는 일이기에 최초 로딩 시에는 일어나지 않는 것이 좋음

### 13.4.2 성능

📍 요약

- 측정 기간의 CPU, 네트워크 요청, 스크린숏, 메모리 점유율 확인

📍 네트워크

- 모든 네트워크 요청 확인
- 그래프 분석
  - 연한 왼쪽 : 요청 보내고 최초 바이트가 오기까지의 대기 시간
  - 진한 오른쪽 : 콘텐츠 다운로드하는 데 걸리는 시간

📍 소요 시간과 기본

- 시간의 흐름에 따라 메인스레드 작업과 JS의 힙 영역 변화

## 13.5 정리

- 성능을 0.1초 개선하는 것만으로도 사용자 경험 개션
- 웹사이트 성능 개선에 대한 관심, 책임감을 키우자
