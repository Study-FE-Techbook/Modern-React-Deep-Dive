# [4장] 서버 사이드 렌더링

## 4.1 서버 사이트 렌더링이란?

### ✨싱글 페이지 애플리케이션의 세상

**📍싱글페이지 애플리케이션이란**

- 렌더링과 라우팅에 필요한 대부분의 기능을 브라우저의 자바스크립트에 의존하는 방식
- 최초에 첫 페이지에서 데이터를 모두 불러온 이후에는 페이지 전환을 위한 모든 작업이 자바스크립트와 브라우저의 history.pushState와 history.replaceState로 이뤄지기 때문에 페이지를 불러온 이후에 하나의 페이지에서 모든 작업을 처리한다.

> **history.pushState** <br>
> 브라우저의 히스토리에 새로운 상태를 추가 (뒤로가기 O)<br>
> 사용자는 새 URL로 이동한 것처럼 보이지만 실제로는 전체 페이지가 다시 로드되지 않는다.<br><br> > **history.replaceState**<br>
> 현재 히스토리 엔트리를 새로운 상태로 대체 (뒤로가기 X)<br>
> 페이지를 다시 로드하지 않고 현재 페이지의 URL을 바꿀 때

1. 사이트 렌더링에 필요한 `<body/>` 내부의 내용을 모두 자바스크립트 코드로 삽입한 이후에 렌더링을 한다.
2. 페이지 전환 시 자바스크립트에서 다음 페이지의 렌더링에 필요한 정보만 HTTP요청 등으로 가져온 후, 그 결과를 바탕으로 body에 DOM을 추가, 수정, 삭제한다.
3. **최초에 서버에서 최소한의 데이터를 불러온 이후에는 이미 가지고 있는 자바스크립트 리소스와 브라우저 API를 기반으루 모든 작동이 이뤄진다.**

> 단점: 최초에 로딩해야 할 자바스크립트 리소스가 커진다.<br>
> 장점: 한번 로딩된 이후에는 서버를 거쳐 필요한 리소스를 받아올 일이 적어 사용자에게 훌륭한 UI/UX를 제공한다.

**📍전통적인 방식의 애플리케이션과 싱글 페이지 애플리케이션의 작동 비교**

| 구분            | 전통적인 방식의 애플리케이션(과거 SSR)                           | 싱글 페이지 애플리케이션(SPA)                                                 |
| --------------- | ---------------------------------------------------------------- | ----------------------------------------------------------------------------- |
| 페이지 전환     | 새로운 페이지를 요청하고 HTML 페이지를 전체적으로 다시 로드      | 현재 페이지를 동적으로 다시 작성해 페이지 전환                                |
| 사용자 경험     | 페이지 전환 시 전체 페이지가 새로 렌더링되어 다소 불편할 수 있음 | 빠른 화면 전환과 부드러운 사용자 경험 제공                                    |
| 네트워크 트래픽 | 페이지 간 이동 시 매번 서버에 요청하므로 네트워크 트래픽 증가    | 필요한 데이터만 비동기로 받아와 렌더링하므로 네트워크 트래픽 감소             |
| 초기 로딩 시간  | 페이지 전환 시 빠른 응답 가능                                    | 모든 정적 리소스를 최초에 다운로드해야 하므로 초기 로딩 시간이 길어질 수 있음 |

> 과거 SSR vs. 현재 SSR
>
> | 구분               | 과거의 SSR                   | 현재의 SSR                                 |
> | ------------------ | ---------------------------- | ------------------------------------------ |
> | 렌더링 방식        | 서버에서 전체 HTML 생성      | 프레임워크/라이브러리를 활용한 혼합 방식   |
> | 초기 로딩 속도     | 빠름                         | 빠름                                       |
> | SEO 적합성         | 높음                         | 높음                                       |
> | 사용자 경험        | 좋지 않음 (페이지 전체 로드) | 개선됨 (클라이언트 측 라우팅 및 상태 관리) |
> | 서버 리소스 사용량 | 높음                         | 낮음                                       |
> | 확장성             | 낮음                         | 높음                                       |
> | 개발자 경험        | 제한적                       | 향상됨 (프레임워크/라이브러리 활용)        |

**📍싱글 페이지 렌더링 방식의 유행과 JAM스택의 등장**

- 과거 PHP나 JSP를 기반으로 대부분의 웹 애플리케이션이 만들어졌을 때는 거의 대부분의 렌더링이 서버사이드에서 이뤄졌다. (페이지를 요청하면 서버에서 완성된 HTML을 내려받고, 페이지 이동이 있으면 새로운 페이지를 서버에서 내려받는 방식)
- 자바스크립트가 서서히 다양한 작업을 수행하게 되면서 CommonJS, AMD가 등장하고, 이후론 우리가 잘 알고 있는 React, vue, Angular가 등장했다.
- 과거에는 자바스크립트에서 할 수 있는 일이 제한적이었기 때문에 대부분의 처리를 서버에서 해야 해서 LAMP(Linux, Apache, Mysql, PHP/Python)스택을 썼다.
- **JAM(Javascript, API, Markup)스택이 등장하고, 대부분의 작업을 자바스크립트에서 수행할 수 있었기 때문에 프론트엔드는 자바스크립트와 마크업을 미리 빌드해 두고 정적으로 사용자에게 제공하면 이후 작동은 모두 사용자의 클라이언트에서 실행되므로 서버 확장성 문제에서 좀 더 자유로워질 수 있었다.**

### ✨서버 사이드 렌더링이란?

- 최초에 사용자에게 보여줄 페이지를 서버에서 렌더링해 빠르게 사용자에게 화면을 제공하는 방식

> SPA - 자바스크립트 번들에서 렌더링<br>
> SSR - 서버에서 렌더링 (안정적임)

**📍서버사이드 렌더링의 장점**

1. **최초 페이지 진입이 비교적 빠르다.**
2. **검색 엔진과 SNS 공유 등 메타데이터 제공이 쉽다**

   > 1. 검색 엔진 로봇이 페이지에 진입한다.
   > 2. 페이지가 HTML 정보를 제공해 로봇이 이 HTML을 다운로드한다. 단, 다운로드만 하고 자바스크립트 코드는 실행하지 않는다.
   > 3. 다운로드한 HTML 페이지 내부의 오픈 그래프나 메타 태그 정보를 기반으로 페이지의 검색정보를 가져오고 이를 바탕으로 검색엔진에 저장한다.

3. **누적 레이아웃 이동이 적다.**

   > ❓누적 레이아웃 이동<br>
   > 사용자에게 페이지를 보여준 이후에 뒤늦게 어떤 HTML정보가 추가되거나 삭제되어 마치 화면이 덜컥거리는 것과 같은 부정적인 사용자 경험

   SSR은 요청이 완전히 완료된 이후에 완성된 페이지를 제공하므로 이런 문제에서 비교적 자유롭다.

4. **사용자의 디바이스 성능에 비교적 자유롭다.**
5. **보안에 좀 더 안전하다.**

**📍서버사이드 렌더링의 단점**

1.  소스코드를 작성할 때 항상 서버를 고려해야 한다.
    브라우저 전역 객체인 window나 sesstionStorage를 쓰면 window is not defined라는 에러를 마주하게 된다. window 사용이 불가피하다면 해당 코드가 서버사이드에서 실행되지 않도록 처리해야 한다.<br>
    `jsx
typeof window !== 'undefined'
`
2.  적절한 서버가 구축돼 있어야 한다.
3.  서비스 지연에 따른 문제
    서버에서 사용자에게 보여줄 페이지에 대한 렌더링 작업이 끝나기 전까지는 사용자에게 그 어떤 정보도 제공할 수 없다.

### ✨SPA와 SSR을 모두 알아야 하는 이유

**📍서버 사이드 렌더링 역시 만능이 아니다**

웹페이지에서 사용자에게 제공하고 싶은 내용이 무엇인지, 또 어떤 우선순위에 따라 페이지의 내용을 보여줄지를 잘 설계하는 것이 중요하다..

**📍싱글 페이지 애플리케이션과 서버 사이드 렌더링 애플리케이션**

1. 가장 뛰어난 싱글 페이지 애플리케이션은 가장 뛰어난 멀티 페이지 애플리케이션보다 낫다.
   SPA는 페이지 전환이 빠르고 부럽고, 필요한 데이터만 비동기로 로드해서 전체적인 성능이 뛰어나다. MPA는 페이지 전환 시 전체 페이지를 다시 로드애햐한다.
2. 평균적인 싱글 페이지 애플리케이션은 평균적인 멀티 페이지 애플리케이션보다 느리다.

   SPA는 모든 정적 리소스를 최초에 다운로드하기 때문에 초기로딩시간이 길다. MPA 는 페이지 전환시 필요한 리소스만 다운로드하기 때문에 초기로딩속도가 빠르다.

**📍현재의 서버 사이드 렌더링**

최초 웹사이트 진입 시에는 SSR로 서버에서 완성된 HTML을 제공받고, 이후 라우팅에서는 서버에서 내려받은 자바스크립트를 바탕으로 마치 싱글 페이지 애플리케이션처럼 작동한다.

> SPA vs. SSR
>
> | 구분           | SPA                      | SSR                           |
> | -------------- | ------------------------ | ----------------------------- |
> | 렌더링         | 클라이언트 측에서 렌더링 | 서버 측에서 렌더링            |
> | 초기 로딩 속도 | 느림                     | 빠름                          |
> | SEO 성능       | 낮음                     | 높음                          |
> | 개발 복잡도    | 낮음                     | 높음                          |
> | 서버 부하      | 낮음                     | 높음                          |
> | 사용자 경험    | 부드러운 사용자 경험     | 새로고침이 필요한 사용자 경험 |
> | 캐싱           | 클라이언트 측 캐싱       | 서버 측 캐싱                  |
> | 보안           | 클라이언트 측 보안       | 서버 측 보안                  |

## 4.2 서버 사이드 렌더링을 위한 리액트 API 살펴보기

### ✨renderToString

- 인수로 넘겨받은 리액트 컴포넌트를 렌더링해 HTML 문자열로 반환하는 함수
- 클라이언트에서 실행되지 않고 일단 먼저 완성된 HTML을 서버에서 제공할 수 있어 초기 렌더링에서 뛰어나다.
- 클라이언트는 이후에 리액트 컴포넌트를 다시 hydration해 상호작용이 가능한 SPA로 전환된다.
- div#root에 생성된 data-reactroot는 리액트 컴포넌트의 루트 엘리먼트가 무엇인지 식별하는 역할로, 추후 `hydrate` 함수에서 루트를 식별하는 기준이 된다.

```jsx
// server.js
import express from 'express'
import React from 'react'
import ReactDOMServer from 'react-dom/server'
import App from './App'

const app = express()

app.get('*', (req, res) => {
  // react 컴포넌트를 HTML 문자열로 변환
  const appString = ReactDOMServer.renderToString(<App />)

  const html = `
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>React SSR Example</title>
      </head>
      <body>
        <div id="root">${appString}</div>
        <script src="/bundle.js"></script>
      </body>
    </html>
  `

  res.send(html)
})

app.listen(3000, () => {
  console.log('Server is running on http://localhost:3000')
})
```

```jsx
// 서버-side 렌더링된 HTML
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>React SSR Example</title>
  </head>
  <body>
    <div id="root" data-reactroot> // !!
      <div>
        <h1>Hello, React SSR!</h1>
      </div>
    </div>
    <script src="/bundle.js"></script>
  </body>
</html>

```

### ✨renderToStaticMarkup

- HTML문자열을 만들지만, reactroot같은 추가적인 DOM 속성을 만들지 않는다.<br>
  → 😲HTML 크기를 아주 약간이라도 줄일 수 있다.
- hydrate를 수행하지 않는다는 가정하에 순수한 HTML만 반환한다.
- 블로그 글이나 상품 약관 정보와 같이 아무런 브라우저 액션이 없는 정적인 내용만 필요한 경우에 유용하다.

### ✨renderToNodeStream

- React 컴포넌트를 스트리밍 방식으로 HTML로 렌더링한다.
- 브라우저에서 사용하는 것이 완전 불가능하다.
- Node.js나 Deno, Bun같은 서버환경에서만 사용할 수 있다.
- 큰 크기의 데이터를 청크단위로 분리해 순차적으로 처리할 수 있다.

> ❓스트림<br>
> 큰 데이터를 다룰 때 데이터를 청크로 분할해 조금씩 가져오는 방식

- 만약 스트림 대신 renderToString을 사용했다면 HTTP응답은 거대한 HTML파일이 완성될 때까지 기다려야 할 것이다.

  ![stream1](./stream1.gif)

  ![stream2](./stream2.gif)

> **❓FCP(First Contentful Paint)**<br>
> 사용자가 페이지를 요청한 후 첫 번째 콘텐츠 요소가 렌더링되는 시간을 측정하는 지표<br>
> 서버에서 페이지를 미리 렌더링하여 HTML을 전송하면, 클라이언트에서 빠르게 첫 번째 콘텐츠를 표시할 수 있다.

> **❓TTI(Time to Interactive)**<br>
> 사용자가 페이지와 상호 작용할 수 있게 되는 시간을 측정하는 지표<br>
> Next.js의 코드 분할 기능을 통해 TTI 성능이 향상된다.<br>
> 코드 분할을 통해 필요한 JavaScript 파일만 로드하여, 페이지가 빠르게 상호 작용 가능한 상태가 된다.

### ✨renderToStaticNodeStream

- `renderToNodeStream`과 비슷하지만, React의 데이터 속성(예: `data-reactroot`) 없이 순수한 HTML을 스트리밍한다.
- hydrate를 할 필요가 없는 순서 HTML 결과물이 필요할 때 사용한다.

### ✨hydrate

- 서버에서 렌더링된 HTML문서와 클라이언트 측 JS코드를 연결하는 과정 → 빠른 초기 로딩 속도
- `renderToString`과 `renderToNodeStream`으로 생성된 HTML 컨텐츠에 자바스크립트 핸들러나 이벤트를 붙이는 역할을 한다.
- 별도의 인수로 HTML 요소를 넘겨서 해당 컴포넌트의 렌더링과 이벤트 핸들러를 붙이는 작업까지 한 번에 수행하는 클라이언트의 `render`와는 다르게, **`hydrate`는 이미 렌더링된 HTML이 있다는 가정하에 작업이 수행되고 이 렌더링된 HTML을 기준으로 이벤트를 붙이는 작업만 실행한다.**

> hydrate vs. render
>
> - `render`: 클라이언트 측에서 새로운 DOM 트리를 생성하고 이벤트 핸들러를 연결하는 작업을 수행한다.
> - `hydrate`: 이미 서버 측에서 렌더링된 HTML 컨텐츠를 기준으로 이벤트 핸들러를 연결하는 작업만 수행한다.
